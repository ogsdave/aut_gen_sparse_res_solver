findsparseresultnat:= proc(eqsinput, vars, sizeofcombs, polycomb, heurisiticbasislength) 
local counter, newpredeigsz, groupsofdifs, modifiedCred, found, tempT, ti, crowstobedelet, rowColCnts, tempCred, Cred, noofTs, tn, C, solverrank, testcoeffmat, minTn, Tn, ii, baks, k, T, Bset, minmonnorm, isbnpresent, Bn, B, interiorintpoints, hp1s, hlfsps, translatedconvhull, delta, deltatoskip, deltasiterator, combind, i, allBs, delt, minkowskis, ind, PForMink, comb, vci, variouscombinations, A, v, P, EE, fIndex, eqs, ll, tempolddigs, indicestotest:
delt := [ -0.01, 0.01, 0]:

eqs := eqsinput:
EE := eval(expand(eqs)):
for fIndex to ArrayTools[Size](EE)[2] do 
	P[fIndex] := newtonpolytope(EE[fIndex], vars):
	v[fIndex] := vertices(P[fIndex]):
	A[fIndex] := lattpts(EE[fIndex], vars): 
    
end do: 
simplex := map(proc (j) options operator, arrow; map(proc (i) options operator, arrow; `if`(i = j, rand(1..4)(), 0) end proc, [seq(1 .. numelems(vars))]) end proc, [seq(1 .. numelems(vars)+1)]):
P[fIndex] := convhull(op(simplex)):
v[fIndex] := vertices(P[fIndex]):
A[fIndex] := vertices(P[fIndex]):
v := convert(v, list):
print(vars):

if numelems(polycomb) = 0 then 
    variouscombinations := (map(proc (l) options operator, arrow; seq(combinat[choose]([seq(1 .. numelems(P))], l)) end proc, sizeofcombs)):
else
    variouscombinations:= [polycomb]: 
end if:

unassign('minkowskis'); 
for vci to numelems(variouscombinations) do 
	comb := variouscombinations[vci]:
	PForMink := []; 
	for ind in comb do 
		PForMink := [op(PForMink), P[ind]]: 
	end do:
	minkowskis[vci] := minkowskisum(op(PForMink)): 
end do:

selectedB := -1:
selectedT := -1:
allBs := []:
oldpredeigsz := infinity:
for combind in combinat[randperm]([seq(1..numelems(variouscombinations))]) do
	randomize():
	printf("Trying out polytopes, %s \n", convert(variouscombinations[combind],string));
    deltasiterator := combinat[cartprod](map(proc (i1) options operator, arrow; map(proc (j) options operator, arrow; delt[j] end proc, [seq(1 .. 3)]) end proc, [seq(1 .. numelems(vars))])):	
    while not deltasiterator[finished] do
       delta := deltasiterator[nextvalue]():
        
		translatedconvhull := minkowskisum(minkowskis[combind], convhull(convert(delta, rational))):
		if dim(translatedconvhull) < numelems(vars) then 
    			next: 
		end if:     
		hp1s := map(rel -> convert(`~`[`*`](lhs(rel), ` $`, vars), `+`) <= rhs(rel), convert(hspaces(translatedconvhull), list)): 

		try
			B := convert(IntegerPoints1(hp1s, vars), list); 
		catch:
			printf("Failed for delta %s \n", convert(delta,string));
			next:
		end try:
		Bn := numelems(B):

		if  Bn = 0 then next: end if:
		minmonnorm := norm(convert(ListTools[FindMinimalElement](B, proc (b1, b2) options operator, arrow; norm(convert(b1-b2,Vector)) = 0 end proc),Vector)):
		# if minmonnorm <> 0 then next: end if:

		Bset := convert(B, set); 
		unassign('T'); 
		for k to numelems(EE) do 
			T[k] := []:
			baks := map(proc (belement) options operator, arrow; op(select(proc (diffba) options operator, arrow; foldl(`and`, true, op(`~`[`>=`](diffba, ` $`, map(proc (ii) options operator, arrow; 0 end proc, [seq(1 .. numelems(vars))])))) end proc, map(proc (aelement) options operator, arrow; `~`[`-`](belement, aelement) end proc, A[k]))) end proc, B):
			for ii to numelems(A[k])-1 do 
				baks := ListTools[FindRepetitions](baks):
			end do: 
			T[k] := convert(convert(convert(baks, set), list), Matrix): 
		end do:
		T := convert(T,list):
		Tn := convert(map(t->ArrayTools[Size](t,1), T), `+`):
		minTn := min(map(t->ArrayTools[Size](t,1), T)):
        
		if Tn >= Bn and minTn > 0 then 
		        temp := convert(T[-1], list, nested = true): 
        		bbs := map(proc (i1) options operator, arrow; select(proc (j1) options operator, arrow; B[j1] = [temp[i1][1], op(temp[i1][2..])] end proc, [seq(1 .. Bn)])[1] end proc, [seq(1 .. numelems(temp))]): 
		        gbs := convert(convert([seq(1 .. numelems(B))], set) minus convert(bbs, set), list):   
                testcoeffmat := polytomat(T, B, EE, vars, Bn, Tn):			
        	    testcoeffmat := LinearAlgebra[Modular][Mod](ithprime(1000), testcoeffmat, integer[8]):
		        #oldpredeigsz := Bn - LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..(Tn - numelems(temp)), ..]):
                solverrank := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat):
	            if Bn = solverrank then
                    newpredaigsz := Bn - LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..(Tn - numelems(temp)), ..]):
                    printf("| Predicted eigenvalue size ............................ %d | \n", newpredaigsz):
    		        if newpredaigsz <= oldpredeigsz and convert(map(b->numelems(b)>Bn, allBs), `and`) then
                        oldpredeigsz := newpredaigsz:
                        if  LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..Tn - numelems(temp), gbs]) = numelems(gbs) then                                                                                    
                            selectedB := B:
                            selectedT := T:
                            allBs := [op(allBs), B]:
                            printf(" .................... \n"):
                            printf(" | %d X %d, %d, %d, %d |\n",Tn, Bn, numelems(bbs), Tn - numelems(temp),LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..(Tn - numelems(temp)), ..]) ):
            	        	printf("delta =  %{t}6f \n", LinearAlgebra[Transpose](convert(delta,Matrix))):
                            printf("Min monomial =  %{t}6d, Max monomial = %{t}6d \n", LinearAlgebra[Transpose](convert(B[1],Matrix)), LinearAlgebra[Transpose](convert(B[-1],Matrix))):
            	            printf("\n"):
                        end if:
                    end if:
                end if:
    		end if:
        end do:
    end do:

if selectedT = -1 then 
	printf("NO SOLVER FOUND .... \n"):
	return convert([],list), convert([],list), [[]]:
end if:

T := selectedT:
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T), `+`):
B := selectedB:
Bn := numelems(B):
C := polytomat(convert(T, list), B, eval(eqs), vars, Bn, Tn); 
testcoeffmat := LinearAlgebra[Modular][Mod](ithprime(1000), C, integer[8]):
solverrank := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat):
printf("obtained a sparse monomial basis...... \n"):
printf("Solver := %d * %d, rank := %d worst case eigensolver size = %d\n", Tn,Bn,solverrank, ArrayTools[Size](T[-1],1)):
Boriginal := B:
temp := convert(T[-1], list, nested = true):
oldpredeigsz := Bn - LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..(Tn - numelems(temp)), ..]):

# Removal of rows and columns =================================================================================================================
B1 := B: T1 := convert(T,list):
T2 := T1: B2 := B1:
found := numelems(B):
#for cnt from 1 to 1 do
    while numelems(B2) > heurisiticbasislength do
    B1 := B: T1 := convert(T,list):
    Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T1), `+`):
    rowindicestotest := [seq(1..Tn)]:
    cstried :=[]:
    printf(" trying with... %d \n", oldpredeigsz):    
    
    #while numelems(B1) > heurisiticbasislength do
    ind := 1;
    inds := []:
    
    while numelems(B1) > heurisiticbasislength do
    	randomize():
        Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T1), `+`):
    	Ctemp := polytomat(T1, B1, eval(eqs), vars, numelems(B1), convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T1), `+`)):
        Ctemp := LinearAlgebra[Modular][Mod](ithprime(1000), Ctemp, integer[8]):
    	Btemp := B1:
    	Ttemp := T1:
        
        temp := convert(Ttemp[-1], list, nested = true):
    	bbs := map(i1 -> select(k -> Btemp[k] = [temp[i1][1], op(temp[i1][2..])], [seq(1 .. numelems(Btemp))])[1], [seq(1 .. numelems(temp))]):
    	gbs := convert(convert([seq(1 .. numelems(Btemp))], set) minus convert(bbs, set), list):    
        
        if numelems(cstried) = numelems(B) then break: end if:
        rowindices := [seq(1..Tn)]:
        colindices := [seq(1..numelems(Btemp))]:
					
        c := [op(combinat[randperm]([op(gbs), op(bbs)])[1..1])]:
        cstried	:= [op(cstried), op(c)]:
        

    	# Cols to remove
        rows2rem := convert(convert(map(j -> op(select(i -> Ctemp[i,j] <> 0, [seq(1..ArrayTools[Size](Ctemp)[1])])), c),set),list):	
        rows2kp := select(proc (j) options operator, arrow; not(j in rows2rem) end proc, [seq(1 .. ArrayTools[Size](Ctemp,1))]): 		
        #if numelems(convert(convert(rows2rem, set) intersect convert([seq((Tn-numelems(temp))..Tn)], set), list)) > 0 then next: end if:
                
        # Modified C
        Ctemp := Ctemp[rows2kp, () .. ()]:                
        if ArrayTools[Size](Ctemp,1) < ArrayTools[Size](Ctemp,2) or ArrayTools[Size](Ctemp,1) = 0 then next: end if:

        Ctempb := map(i -> `if`(i = 0, 0, 1), Ctemp):     
        zdcols := convert(ArrayTools[AddAlongDimension](Ctempb, 1), list):
        colstokp := select(j -> zdcols[j] <> 0, [seq(1 .. numelems(zdcols))]):
        cols2rem := select(j -> zdcols[j] = 0, [seq(1 .. numelems(zdcols))]):     
        Ctemp := Ctemp[() .. (), colstokp]: 
        Btemp := Btemp[colstokp]:                
        if numelems(cols2rem) = 0  then next: end if:        

        rowindices := rowindices[rows2kp]:
        Ttemp:=map(k -> Ttemp[k][select(j -> j+convert(map(t->ArrayTools[Size](Ttemp[t],1), [seq(1 .. numelems(Ttemp[..k-1]))]), `+`) in rowindices, [seq(1..ArrayTools[Size](Ttemp[k],1))]),..], [seq(1..numelems(Ttemp))]):	
    	if convert(map(t->ArrayTools[Size](t,1), Ttemp), `*`) = 0  then next: end if:               

        temp := convert(Ttemp[-1], list, nested = true):
        bbs := map(i1 -> select(k -> Btemp[k] = [temp[i1][1], op(temp[i1][2..])], [seq(1 .. numelems(Btemp))])[1], [seq(1 .. numelems(temp))]):
        gbs := convert(convert([seq(1 .. numelems(Btemp))], set) minus convert(bbs, set), list):
        Ck := Ctemp[[seq(1..convert(map(t -> ArrayTools[Size](t,1), Ttemp[..-2]), `+`))], gbs]:
        difff := ArrayTools[Size](Ck)[2]-LinearAlgebra[Modular][Rank](ithprime(1000), Ck):        
        if (difff <> 0)  then next: end if:

        newpredeigsz := numelems(Btemp) - LinearAlgebra[Modular][Rank](ithprime(1000), Ctemp[1..convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, Ttemp[..-2]), `+`), ..]):        
        if newpredeigsz > oldpredeigsz then next: end if:
        print(c, numelems(rows2rem), numelems(cols2rem), ArrayTools[Size](Ctemp), numelems(bbs), difff, newpredeigsz);
        B1 := Btemp:
        T1 := Ttemp:    
        cstried := []:    
        rowindicestotest := rowindicestotest[rowindices]:     
        inds := [op(inds), op(c)]:   
    end do:

    if found > numelems(B1) then 
        T2 := T1:
        B2 := B1:
        found := numelems(B1):
        print(inds):
    end if:
end do:

T:=T2: B:=B2:
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T), `+`):
C := polytomat(convert(T, list), B, eval(eqs), vars, numelems(B), Tn): 
printf("Solver := %d * %d, Current T = %s \n", Tn, numelems(B), convert(map(t->ArrayTools[Size](t)[1], T), string)):
# =============================================================================================================
# =============================================================================================================
# For tracking an indice, we add '1' to the end of each element in the list of monomial multiples
tn := 0:
noofTs := ArrayTools[Size](T)[2]:
for k to  noofTs do
	T[k] := convert((map(proc (t) options operator, arrow; [op(convert(T[k][t], list)), t+tn] end proc, [seq(1 .. ArrayTools[Size](T[k])[1])])), Matrix):
	tn := tn + ArrayTools[Size](T[k])[1]:
end do:
# =============================================================================================================

printf("Reducing the rows to get a reduced matrix with smaller basis.\n"):
# =============================================================================================================
# =============================================================================================================
print(B);
noofnonzelems := infinity:
for counter from 1 to 500 do
    randomize():
    Cred := LinearAlgebra[Copy](LinearAlgebra[Modular][Mod](ithprime(1000), C, integer[8])):
    T1 := T:
    tempCred := Cred:
    rowColCnts := ArrayTools[Size](Cred):
    crowstobedelet := []:

    ll := max(map(proc (ti) options operator, arrow; ArrayTools[Size](ti)[1] end proc, T1)):
    indicestotest := [seq(1..Tn)]: 
    temp := ListTools[Reverse](ListTools[Reverse]([seq(1..convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T1), `+`))])[1..ArrayTools[Size](T1[-1],1)]):
        
    indicestoskip := []:
    #indicestoskip := [op(indicestoskip),op(select(i -> convert(convert(T1[-1][i  - (tn-ArrayTools[Size](T1[-1],1)) ,..-2], list), `+`) <= 1, temp))]:

    temp := convert(convert(temp, set) minus convert(indicestoskip,set), list):
    #indicestotest := convert(convert(indicestotest, set) minus convert(indicestoskip,set), list):
    p1 := convert(convert(indicestotest,set) minus convert(temp,set), list):
    indicestotest := [op(combinat[randperm](temp)), op(p1[1..0]), op(combinat[randperm](p1[1..]))]:
    
    for i in indicestotest do 
	for ti to noofTs do 
		tempT := T1[ti]; 
		found := select(proc (ti1) options operator, arrow; T1[ti][ti1][-1] = i end proc, [seq(1 .. ArrayTools[Size](T1[ti])[1])]); 
		if numelems(found) > 0 then 
            tempT := LinearAlgebra[DeleteRow](T1[ti], found); 
            break: 
		end if: 
	end do; 
	modifiedCred := LinearAlgebra[DeleteRow](tempCred, [op(crowstobedelet), i]):
	testcoeffmat := LinearAlgebra[Modular][Mod](ithprime(1000), modifiedCred, integer[8]):
	solverrank := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat):
    
	if ArrayTools[Size](tempT)[1] > 0 then 
		if solverrank = rowColCnts[2] then
			
			tempTT := T1:
			tempTT[ti] := LinearAlgebra[DeleteRow](tempTT[ti], found):
			temp := convert(tempTT[-1], list, nested = true): 
			bbs := map(proc (i1) options operator, arrow; select(proc (j1) options operator, arrow; B[j1] = [temp[i1][1], op(temp[i1][2..-2])] end proc, [seq(1 .. numelems(B))])[1] end proc, [seq(1 .. numelems(temp))]): 
			gbs := convert(convert([seq(1 .. numelems(B))], set) minus convert(bbs, set), list):
            rankofgdblck := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1 .. convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, tempTT[() .. -2]), `+`), gbs]):			
			if rankofgdblck = numelems(gbs)   then
				Cred := modifiedCred:
				T1[ti] := LinearAlgebra[DeleteRow](T1[ti], found):
				crowstobedelet := [op(crowstobedelet), i]:
				rowColCnts := ArrayTools[Size](Cred):
			end if:
		end if:		
	end if:
end do:

    for k to ArrayTools[Size](T)[2] do
	    T1[k] := convert((map(proc (t) options operator, arrow; [op(convert(T1[k][t][..-2], list))] end proc, [seq(1 .. ArrayTools[Size](T1[k])[1])])), Matrix):
    end do:

    temp := convert(T1[-1], list, nested = true):
    bbs := map(i1 -> select(j1 ->  B[j1] = [temp[i1][1], op(temp[i1][2..])], [seq(1 .. numelems(B))])[1], [seq(1 .. numelems(temp))]): 
    gbs := convert(convert([seq(1 .. numelems(B))], set) minus convert(bbs, set), list):
    Cr := polytomat(convert(T1, list), B, eval(eqs), vars, numelems(B), convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T1), `+`)):
    temp := Cr[1 .. convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T1[() .. -2]), `+`), gbs]:
    
    k := numelems(select(t->t<>0, convert(temp,list))):
    #DIGITS := 20:
    #k := LinearAlgebra[ConditionNumber](evalf(temp)):
    if k < noofnonzelems then 
        T2 := T1:
        noofnonzelems  := k:
        print(k);
        printf("%d",convert(indicestotest,Matrix));
    end if:
    #DIGITS := 10:

if ArrayTools[Size](Cred,1) = ArrayTools[Size](Cred,2) then print("Row indices to be deleted ", convert(crowstobedelet,string));  break: end if:
end do:
T := T2:

print(T, numelems(B), "........................................");
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T), `+`):

# =============================================================================================================
Cr := polytomat(convert(T, list), B, eval(eqs), vars, numelems(B), convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T), `+`)):

return Boriginal, selectedT, B, T:
end proc: