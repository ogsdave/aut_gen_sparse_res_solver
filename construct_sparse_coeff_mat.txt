removeexcessrows := proc(B, T, eqs, vars) 
local counter, groupsofdifs, modifiedCred, found, tempT, ti, crowstobedelet, rowColCnts, tempCred, Cred, noofTs, tn, C, solverrank, testcoeffmat, minTn, Tn, ii, baks, k, Bset, minmonnorm, isbnpresent, Bn, interiorintpoints, hp1s, hlfsps, translatedconvhull, delta, deltatoskip, deltasiterator, combind, i, minmonomialnorms, allTs, allBs, allBbss, allBns, currentminsolver, bestbasisindx, delt, minkowskis, ind, PForMink, comb, vci, variouscombinations, A, v, P, EE, fIndex, index, ll, tempolddigs, indicestotest:
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T), `+`):
C := polytomat(convert(T, list), B, eval(eqs), vars, numelems(B), Tn): 

# =============================================================================================================
# =============================================================================================================
# For tracking an indice, we add '1' to the end of each element in the list of monomial multiples
noofTs := ArrayTools[Size](T)[2]:

# =============================================================================================================

# =============================================================================================================
# =============================================================================================================
noofnonzelems := infinity:
for counter from 1 to 100 do
    randomize():
    Cred := LinearAlgebra[Copy](LinearAlgebra[Modular][Mod](ithprime(1000), C, integer[8])):
	
    T1 := T:
	tn := 0:
	for k to  noofTs do
		T1[k] := convert((map(proc (t) options operator, arrow; [op(convert(T1[k][t], list)), t+tn] end proc, [seq(1 .. ArrayTools[Size](T1[k])[1])])), Matrix):
		tn := tn + ArrayTools[Size](T1[k])[1]:
	end do:

    tempCred := Cred:
    rowColCnts := ArrayTools[Size](Cred):
    crowstobedelet := []:
	
    ll := max(map(proc (ti) options operator, arrow; ArrayTools[Size](ti)[1] end proc, T1)):
    indicestotest := [seq(1..Tn)]: 
    temp := ListTools[Reverse](ListTools[Reverse]([seq(1..convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T1), `+`))])[1..ArrayTools[Size](T1[-1],1)]):
        
    indicestoskip := []:
    #indicestoskip := [op(indicestoskip),op(select(i -> convert(convert(T1[-1][i  - (tn-ArrayTools[Size](T1[-1],1)) ,..-2], list), `+`) <= 1, temp))]:
    temp := convert(convert(temp, set) minus convert(indicestoskip,set), list):
    indicestotest := convert(convert(indicestotest, set) minus convert(indicestoskip,set), list):
    p1 := ListTools[Reverse](convert(convert(indicestotest,set) minus convert(temp,set), list)):
    indicestotest := [op(combinat[randperm](temp)), op((p1[1..1])), op(combinat[randperm](p1[2..])) ]:

    for i in indicestotest do 
	for ti to noofTs do 
		tempT := T1[ti]; 
		found := select(proc (ti1) options operator, arrow; T1[ti][ti1][-1] = i end proc, [seq(1 .. ArrayTools[Size](T1[ti])[1])]); 
		if numelems(found) > 0 then 
            tempT := LinearAlgebra[DeleteRow](T1[ti], found); 
            break: 
		end if: 
	end do; 
	modifiedCred := LinearAlgebra[DeleteRow](tempCred, [op(crowstobedelet), i]):
	testcoeffmat := LinearAlgebra[Modular][Mod](ithprime(1000), modifiedCred, integer[8]):
	solverrank := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat):
	
	if ArrayTools[Size](tempT)[1] > 0 then 
		if solverrank = rowColCnts[2] then
			
			tempTT := T1:
			tempTT[ti] := LinearAlgebra[DeleteRow](tempTT[ti], found):
			temp := convert(tempTT[-1], list, nested = true): 
			bbs := map(proc (i1) options operator, arrow; select(proc (j1) options operator, arrow; B[j1] = [temp[i1][1], op(temp[i1][2..-2])] end proc, [seq(1 .. numelems(B))])[1] end proc, [seq(1 .. numelems(temp))]): 
			gbs := convert(convert([seq(1 .. numelems(B))], set) minus convert(bbs, set), list):
            rankofgdblck := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1 .. convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, tempTT[() .. -2]), `+`), gbs]):
			
			if rankofgdblck = numelems(gbs)   then
				Cred := modifiedCred:
				T1[ti] := LinearAlgebra[DeleteRow](T1[ti], found):
				crowstobedelet := [op(crowstobedelet), i]:
				rowColCnts := ArrayTools[Size](Cred):
			end if:
		end if:		
	end if:
end do:

    for k to ArrayTools[Size](T)[2] do
	    T1[k] := convert((map(proc (t) options operator, arrow; [op(convert(T1[k][t][..-2], list))] end proc, [seq(1 .. ArrayTools[Size](T1[k])[1])])), Matrix):
    end do:

if ArrayTools[Size](Cred,1) = ArrayTools[Size](Cred,2) then break: end if:
end do:

T2 := T1:

return T2:
end proc:


findsparseresultnat:= proc(eqsinput, vars, sizeofcombs, polycomb, actualnoofsolns, heurisiticbasislength) 
local counter, newpredeigsz, groupsofdifs, modifiedCred, found, tempT, ti, crowstobedelet, rowColCnts, tempCred, Cred, noofTs, tn, C, solverrank, testcoeffmat, minTn, Tn, ii, baks, k, T, Bset, minmonnorm, isbnpresent, Bn, B, interiorintpoints, hp1s, hlfsps, translatedconvhull, delta, deltatoskip, deltasiterator, combind, i, minmonomialnorms, allTs, allBs, allBbss, allBns, currentminsolver, bestbasisindx, delt, minkowskis, ind, PForMink, comb, vci, variouscombinations, A, v, P, EE, fIndex, index, eqs, ll, tempolddigs, indicestotest:
delt := [ -0.01, 0.01, 0]:

eqs := eqsinput:
EE := eval(expand(eqs)):
for fIndex to ArrayTools[Size](EE)[2] do 
	P[fIndex] := newtonpolytope(EE[fIndex], vars):
	v[fIndex] := vertices(P[fIndex]):
	A[fIndex] := lattpts(EE[fIndex], vars): 
    
end do: 
simplex := map(proc (j) options operator, arrow; map(proc (i) options operator, arrow; `if`(i = j, rand(1..4)(), 0) end proc, [seq(1 .. numelems(vars))]) end proc, [seq(1 .. numelems(vars)+1)]):
P[fIndex] := convhull(op(simplex)):
v[fIndex] := vertices(P[fIndex]):
A[fIndex] := vertices(P[fIndex]):
v := convert(v, list):

counter := combinat[cartprod](map(i-> [1,2,3], [seq(1..numelems(vars))])):

simplex := counter[nextvalue]():
print(simplex);
simplex := map(j -> map(i ->  `if`(i = j, simplex[i], 0), [seq(1 .. numelems(vars))]), [seq(1 .. numelems(vars)+1)]):
P[fIndex] := convhull(op(simplex)):
v[fIndex] := vertices(P[fIndex]):
A[fIndex] := vertices(P[fIndex]):
print(A[fIndex]);

if numelems(polycomb) = 0 then 
    variouscombinations := (map(proc (l) options operator, arrow; seq(combinat[choose]([seq(1 .. numelems(P))], l)) end proc, sizeofcombs)):
else
    variouscombinations:= [polycomb]: 
end if:
unassign('minkowskis'); 
for vci to numelems(variouscombinations) do 
	comb := variouscombinations[vci]:
	PForMink := []; 
	for ind in comb do 
		PForMink := [op(PForMink), P[ind]]: 
	end do:
	minkowskis[vci] := minkowskisum(op(PForMink)): 
end do:

bestbasisindx := 0:
currentminsolver := infinity:
allBns := []:
allBs := []:
allBbss := []:
allTs := []:
minmonomialnorms := []:
index := 1:
bestbasisindx := -1:
oldpredeigsz := 10000000:
for combind in combinat[randperm]([seq(1..numelems(variouscombinations))]) do
	randomize():
    
	printf("Trying out polytopes, %s \n", convert(variouscombinations[combind],string));

    # for delta in [[-0.1e-1, 0, 0, 0, 0.1e-1, -0.1e-1, 0.1e-1, -0.1e-1]] do # hiding a7
    # for delta in [[0.1e-1, 0.1e-1, 0.1e-1, 0.1e-1, 0, 0.1e-1]] do # hiding a3
    # for delta in [[-0.010000, -0.010000, -0.010000, 0.010000, 0.000000, 0.010000]] do
    # for delta in [[0.000000, -0.010000, -0.010000, 0.000000 ]] do # for a4 for p2pf
    # for delta in [[0.010000, 0.010000, 0.010000, 0.010000, -0.010000, 0.000000]] do # a1 for p6pf alternate
    # for delta in [[0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.000000]] do # for a1 p6pf original

    deltasiterator := convert(convert(map(c -> c, combinat[permute](map(k-> op(delt), [seq(1..numelems(vars))]), numelems(vars))), set),list):	    
    randomize():
    for delta in combinat[randperm](deltasiterator)[1..numelems(deltasiterator)][1..100] do	

    # deltasiterator := combinat[cartprod](map(proc (i1) options operator, arrow; map(proc (j) options operator, arrow; delt[j] end proc, [seq(1 .. 3)]) end proc, [seq(1 .. numelems(vars))])):	
    # while not deltasiterator[finished] do
    #    delta := deltasiterator[nextvalue]():
        
		translatedconvhull := minkowskisum(minkowskis[combind], convhull(convert(delta, rational))):
		if dim(translatedconvhull) < numelems(vars) then 
    			next: 
		end if:
     
		hlfsps := convert(hspaces(translatedconvhull), list):
		hp1s := map(rel -> convert(`~`[`*`](lhs(rel), ` $`, vars), `+`) <= rhs(rel), hlfsps): 

		try
			B := convert(IntegerPoints1(hp1s, vars), list); 
		catch:
			printf("Failed for delta %s \n", convert(delta,string));
			next:
		end try:
		Bn := numelems(B):

		# Skip if no basis was found
		if  Bn = 0 then next: end if:
        if Bn > 500 then next: end if:

		minmonnorm := norm(convert(ListTools[FindMinimalElement](B, proc (b1, b2) options operator, arrow; norm(convert(b1-b2,Vector)) = 0 end proc),Vector)):
		if minmonnorm <> 0 then next: end if:

		Bset := convert(B, set); 
		unassign('T'); 
		for k to numelems(EE) do 
			T[k] := []:

			baks := map(proc (belement) options operator, arrow; op(select(proc (diffba) options operator, arrow; foldl(`and`, true, op(`~`[`>=`](diffba, ` $`, map(proc (ii) options operator, arrow; 0 end proc, [seq(1 .. numelems(vars))])))) end proc, map(proc (aelement) options operator, arrow; `~`[`-`](belement, aelement) end proc, A[k]))) end proc, B):
			for ii to numelems(A[k])-1 do 
				baks := ListTools[FindRepetitions](baks):
			end do: 
			T[k] := convert(convert(convert(baks, set), list), Matrix): 
		end do:
		T := convert(T,list):
		Tn := convert(map(at -> ArrayTools[Size](T[at])[1], [seq(1..numelems(EE))]), `+`):
		minTn := min(map(at -> ArrayTools[Size](T[at])[1], [seq(1..numelems(EE))])):
		if Tn >= Bn and minTn > 0 then 
		        temp := convert(T[-1], list, nested = true): 
        		bbs := map(proc (i1) options operator, arrow; select(proc (j1) options operator, arrow; B[j1] = [temp[i1][1], op(temp[i1][2..])] end proc, [seq(1 .. Bn)])[1] end proc, [seq(1 .. numelems(temp))]): 
		        gbs := convert(convert([seq(1 .. numelems(B))], set) minus convert(bbs, set), list):   
                testcoeffmat := polytomat(T, B, EE, vars, Bn, Tn):			
        	    testcoeffmat := LinearAlgebra[Modular][Mod](ithprime(1000), testcoeffmat, integer[8]):
		        #oldpredeigsz := Bn - LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..(Tn - numelems(temp)), ..]):
                solverrank := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat):
	            if Bn = solverrank then
                    found := Bn - LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..(Tn - numelems(temp)), ..]):
                    printf("| Predicted eigenvalue size ............................ %d | \n", found):
    		        if found <= oldpredeigsz and convert(  map(i -> numelems(i) >= Bn, allBs), `and`)  then
                        oldpredeigsz := found:
                        if  LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..Tn - numelems(temp), gbs]) = numelems(gbs) then                                                                                    
                            allTs := [op(allTs), T]:
                            allBs := [op(allBs), B]:                        
                            allBbss := [op(allBbss), B[bbs]]:
                            minmonomialnorms := [op(minmonomialnorms), minmonnorm]:
                            allBns := [op(allBns), numelems(B[bbs])]:
                            index := index + 1:
                            printf(" .................... \n"):
                            printf(" | %d X %d, %d, %d, %d |\n",Tn, Bn, numelems(bbs), Tn - numelems(temp),LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..(Tn - numelems(temp)), ..]) ):                            
            	        	printf("delta =  %{t}6f \n", LinearAlgebra[Transpose](convert(delta,Matrix))):
                            printf("Min monomial =  %{t}6d, Max monomial = %{t}6d \n", LinearAlgebra[Transpose](convert(B[1],Matrix)), LinearAlgebra[Transpose](convert(B[-1],Matrix))):
    	                	bestbasisindx := index-1:
                            printf(" ....................  %d \n", bestbasisindx):
            	            printf("\n"):
                            currentminsolver := numelems(B):                           
                        end if:
                    end if:
                end if:
    		end if:
        end do:
    end do:

if bestbasisindx = -1 then 
	printf("NO SOLVER FOUND .... \n"):
	return convert([],list), convert([],list), [[]]:
end if:

T := allTs[bestbasisindx]:
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T), `+`):
B := allBs[bestbasisindx]:
Bn := numelems(B):
C := polytomat(convert(T, list), B, eval(eqs), vars, Bn, Tn); 
testcoeffmat := LinearAlgebra[Modular][Mod](ithprime(1000), C, integer[8]):
solverrank := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat):
printf("obtained a solution, %d\n",bestbasisindx ):
printf("Solver := %d * %d, rank := %d worst case eigensolver size = %d\n", Tn,Bn,solverrank, ArrayTools[Size](T[-1],1)):
Boriginal := B:
temp := convert(T[-1], list, nested = true):
oldpredeigsz := Bn - LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1..(Tn - numelems(temp)), ..]):
# Removal of rows and columns =================================================================================================================
B1 := B: T1 := convert(T,list):
T2 := T1: B2 := B1:
found := numelems(B):
#for cnt from 1 to 1 do
    while numelems(B2) > heurisiticbasislength do
    B1 := B: T1 := convert(T,list):
    Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T1), `+`):
    rowindicestotest := [seq(1..Tn)]:
    cstried :=[]:
    printf(" trying with... %d \n", oldpredeigsz):    
    
    #while numelems(B1) > heurisiticbasislength do
    ind := 1;
    inds := []:
    
    while numelems(B1) > heurisiticbasislength do
    	randomize():
        Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T1), `+`):
    	Ctemp := polytomat(T1, B1, eval(eqs), vars, numelems(B1), convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T1), `+`)):
        Ctemp := LinearAlgebra[Modular][Mod](ithprime(1000), Ctemp, integer[8]):
    	Btemp := B1:
    	Ttemp := T1:
        
        temp := convert(Ttemp[-1], list, nested = true):
    	bbs := map(i1 -> select(k -> Btemp[k] = [temp[i1][1], op(temp[i1][2..])], [seq(1 .. numelems(Btemp))])[1], [seq(1 .. numelems(temp))]):
    	gbs := convert(convert([seq(1 .. numelems(Btemp))], set) minus convert(bbs, set), list):    
        
        if numelems(cstried) = numelems(B) then break: end if:
        rowindices := [seq(1..Tn)]:
        colindices := [seq(1..numelems(Btemp))]:
					
        c := [op(combinat[randperm]([op(gbs), op(bbs)])[1..1])]:
        if ind > numelems(inds) then 
           #c := [op(combinat[randperm]([op(gbs), op(bbs)])[1..1])]:
           #break:
        else
            #c := [inds[ind]]:
            #ind := ind+1:
        end if:
        cstried	:= [op(cstried), op(c)]:
        

    	# Cols to remove
        rows2rem := convert(convert(map(j -> op(select(i -> Ctemp[i,j] <> 0, [seq(1..ArrayTools[Size](Ctemp)[1])])), c),set),list):	
        rows2kp := select(proc (j) options operator, arrow; not(j in rows2rem) end proc, [seq(1 .. ArrayTools[Size](Ctemp,1))]): 		
        #if numelems(convert(convert(rows2rem, set) intersect convert([seq((Tn-numelems(temp))..Tn)], set), list)) > 0 then next: end if:
                
        # Modified C
        Ctemp := Ctemp[rows2kp, () .. ()]:                
        if ArrayTools[Size](Ctemp,1) < ArrayTools[Size](Ctemp,2) or ArrayTools[Size](Ctemp,1) = 0 then next: end if:

        Ctempb := map(i -> `if`(i = 0, 0, 1), Ctemp):     
        zdcols := convert(ArrayTools[AddAlongDimension](Ctempb, 1), list):
        colstokp := select(j -> zdcols[j] <> 0, [seq(1 .. numelems(zdcols))]):
        cols2rem := select(j -> zdcols[j] = 0, [seq(1 .. numelems(zdcols))]):     
        Ctemp := Ctemp[() .. (), colstokp]: 
        Btemp := Btemp[colstokp]:                
        if numelems(cols2rem) = 0  then next: end if:        

        rowindices := rowindices[rows2kp]:
        Ttemp:=map(k -> Ttemp[k][select(j -> j+convert(map(t->ArrayTools[Size](Ttemp[t],1), [seq(1 .. numelems(Ttemp[..k-1]))]), `+`) in rowindices, [seq(1..ArrayTools[Size](Ttemp[k],1))]),..], [seq(1..numelems(Ttemp))]):	
    	if convert(map(t->ArrayTools[Size](t,1), Ttemp), `*`) = 0  then next: end if:               

        temp := convert(Ttemp[-1], list, nested = true):
        bbs := map(i1 -> select(k -> Btemp[k] = [temp[i1][1], op(temp[i1][2..])], [seq(1 .. numelems(Btemp))])[1], [seq(1 .. numelems(temp))]):
        gbs := convert(convert([seq(1 .. numelems(Btemp))], set) minus convert(bbs, set), list):
        Ck := Ctemp[[seq(1..convert(map(t -> ArrayTools[Size](t,1), Ttemp[..-2]), `+`))], gbs]:
        difff := ArrayTools[Size](Ck)[2]-LinearAlgebra[Modular][Rank](ithprime(1000), Ck):        
        if (difff <> 0)  then next: end if:

        newpredeigsz := numelems(Btemp) - LinearAlgebra[Modular][Rank](ithprime(1000), Ctemp[1..convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, Ttemp[..-2]), `+`), ..]):        
        if newpredeigsz > oldpredeigsz then next: end if:
        print(c, numelems(rows2rem), numelems(cols2rem), ArrayTools[Size](Ctemp), numelems(bbs), difff, newpredeigsz);
        B1 := Btemp:
        T1 := Ttemp:    
        cstried := []:    
        rowindicestotest := rowindicestotest[rowindices]:     
        inds := [op(inds), op(c)]:   
    end do:
    if found > numelems(B1) then 
        T2 := T1:
        B2 := B1:
        found := numelems(B1):
        print(inds):
    end if:
end do:

T:=T2: B:=B2:
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T), `+`):
C := polytomat(convert(T, list), B, eval(eqs), vars, numelems(B), Tn): 
printf("Solver := %d * %d, Current T = %s \n", Tn, numelems(B), convert(map(t->ArrayTools[Size](t)[1], T), string)):
# =============================================================================================================
# =============================================================================================================
# For tracking an indice, we add '1' to the end of each element in the list of monomial multiples
tn := 0:
noofTs := ArrayTools[Size](T)[2]:
for k to  noofTs do
	T[k] := convert((map(proc (t) options operator, arrow; [op(convert(T[k][t], list)), t+tn] end proc, [seq(1 .. ArrayTools[Size](T[k])[1])])), Matrix):
	tn := tn + ArrayTools[Size](T[k])[1]:
end do:
# =============================================================================================================

printf("Reducing the rows to get a reduced matrix with smaller basis.\n"):
# =============================================================================================================
# =============================================================================================================
print(B);
noofnonzelems := infinity:
for counter from 1 to 500 do
    randomize():
    Cred := LinearAlgebra[Copy](LinearAlgebra[Modular][Mod](ithprime(1000), C, integer[8])):
    T1 := T:
    tempCred := Cred:
    rowColCnts := ArrayTools[Size](Cred):
    crowstobedelet := []:

    ll := max(map(proc (ti) options operator, arrow; ArrayTools[Size](ti)[1] end proc, T1)):
    indicestotest := [seq(1..Tn)]: 
    temp := ListTools[Reverse](ListTools[Reverse]([seq(1..convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T1), `+`))])[1..ArrayTools[Size](T1[-1],1)]):
        
    indicestoskip := []:
    #indicestoskip := [op(indicestoskip),op(select(i -> convert(convert(T1[-1][i  - (tn-ArrayTools[Size](T1[-1],1)) ,..-2], list), `+`) <= 1, temp))]:

    temp := convert(convert(temp, set) minus convert(indicestoskip,set), list):
    #indicestotest := convert(convert(indicestotest, set) minus convert(indicestoskip,set), list):
    p1 := convert(convert(indicestotest,set) minus convert(temp,set), list):
    indicestotest := [op(combinat[randperm](temp)), op(p1[1..0]), op(combinat[randperm](p1[1..]))]:
    
    for i in indicestotest do 
	for ti to noofTs do 
		tempT := T1[ti]; 
		found := select(proc (ti1) options operator, arrow; T1[ti][ti1][-1] = i end proc, [seq(1 .. ArrayTools[Size](T1[ti])[1])]); 
		if numelems(found) > 0 then 
            tempT := LinearAlgebra[DeleteRow](T1[ti], found); 
            break: 
		end if: 
	end do; 
	modifiedCred := LinearAlgebra[DeleteRow](tempCred, [op(crowstobedelet), i]):
	testcoeffmat := LinearAlgebra[Modular][Mod](ithprime(1000), modifiedCred, integer[8]):
	solverrank := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat):
    
	if ArrayTools[Size](tempT)[1] > 0 then 
		if solverrank = rowColCnts[2] then
			
			tempTT := T1:
			tempTT[ti] := LinearAlgebra[DeleteRow](tempTT[ti], found):
			temp := convert(tempTT[-1], list, nested = true): 
			bbs := map(proc (i1) options operator, arrow; select(proc (j1) options operator, arrow; B[j1] = [temp[i1][1], op(temp[i1][2..-2])] end proc, [seq(1 .. numelems(B))])[1] end proc, [seq(1 .. numelems(temp))]): 
			gbs := convert(convert([seq(1 .. numelems(B))], set) minus convert(bbs, set), list):
            rankofgdblck := LinearAlgebra[Modular][Rank](ithprime(1000), testcoeffmat[1 .. convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, tempTT[() .. -2]), `+`), gbs]):			
			if rankofgdblck = numelems(gbs)   then
				Cred := modifiedCred:
				T1[ti] := LinearAlgebra[DeleteRow](T1[ti], found):
				crowstobedelet := [op(crowstobedelet), i]:
				rowColCnts := ArrayTools[Size](Cred):
			end if:
		end if:		
	end if:
end do:

    for k to ArrayTools[Size](T)[2] do
	    T1[k] := convert((map(proc (t) options operator, arrow; [op(convert(T1[k][t][..-2], list))] end proc, [seq(1 .. ArrayTools[Size](T1[k])[1])])), Matrix):
    end do:

    temp := convert(T1[-1], list, nested = true):
    bbs := map(i1 -> select(j1 ->  B[j1] = [temp[i1][1], op(temp[i1][2..])], [seq(1 .. numelems(B))])[1], [seq(1 .. numelems(temp))]): 
    gbs := convert(convert([seq(1 .. numelems(B))], set) minus convert(bbs, set), list):
    Cr := polytomat(convert(T1, list), B, eval(eqs), vars, numelems(B), convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T1), `+`)):
    temp := Cr[1 .. convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T1[() .. -2]), `+`), gbs]:
    
    k := numelems(select(t->t<>0, convert(temp,list))):
    #DIGITS := 20:
    #k := LinearAlgebra[ConditionNumber](evalf(temp)):
    if k < noofnonzelems then 
        T2 := T1:
        noofnonzelems  := k:
        print(k);
        printf("%d",convert(indicestotest,Matrix));
    end if:
    #DIGITS := 10:

if ArrayTools[Size](Cred,1) = ArrayTools[Size](Cred,2) then print("Row indices to be deleted ", convert(crowstobedelet,string));  break: end if:
end do:
T := T2:

print(T, numelems(B), "........................................");
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T), `+`):

# =============================================================================================================
Cr := polytomat(convert(T, list), B, eval(eqs), vars, numelems(B), convert(map(proc (t) options operator, arrow; ArrayTools[Size](t)[1] end proc, T), `+`)):

return Boriginal, allTs[bestbasisindx], B, T:
end proc: