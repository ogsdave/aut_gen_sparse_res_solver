solverFolderName :=sp_solvers/problem_stitching:
sizeofcombs := [1]:
heurisitictemplatesize := 34:
noofdatacoeff :=32:
varorder := []:
theoreticalsolncnt:=18:
polycomb := [1,2]:
read cat(solverFolderName, "/Eqs.txt"): 
read "construct_sparse_coeff_mat.txt":
read "polysolver.map":
read "ComputeSparsePolyBasis.txt": 
march('open', "convex.mla"):
read "IntegerPoints.txt":
with(convex):
eqs := convert(eqs, list):


selectedhiddenvarind := -1:
if hiddenVarNumber = -1 then
	fr := 1:
	en := numelems(vars):
else
	fr := hiddenVarNumber:
	en := hiddenVarNumber:
end if:

for hiddenvarind from fr to en do

    hiddenVarNumber := hiddenvarind:
    hiddenVar := parse(cat("a", hiddenVarNumber)):
    unHiddenVars := select(v -> v <> hiddenVar, vars):
    printf("Trying out by hidding variable  %s \n.", cat("a", hiddenVarNumber));

    newHiddenVarNumber := max(map(v->parse(substring(v,2..)),vars))+1:
    acthiddenvarnumber := newHiddenVarNumber:
    vars := [cat('a',hiddenVarNumber), op(unHiddenVars),cat('a',newHiddenVarNumber)]:
    eqs := [op(eqs), vars[1] - vars[-1] ]:

    unHiddenVars := vars[..-2]:
    hiddenVarNumber := newHiddenVarNumber:
    hiddenVar := parse(cat("a", hiddenVarNumber)):
    print(unHiddenVars, vars, hiddenVarNumber, eqs[-1]);

    CUDA[Enable](true):
    printf("CUDA enabled : %s \n",CUDA[IsEnabled]());

    if numelems(polycomb) = 0 then polycomb := []: end if:
        randrange := -1000000..1000000:
        randomize():

        Bn := min():
        sparsebasis := []:
        #======================================================================================
        # Iterate through all possible permutations of the variables in question. 
        #======================================================================================

    for varperm in [combinat[permute](vars)[1]] do
            #======================================================================================
            # Convert polynomial equations to matrix form	
            #======================================================================================
    
            M, originalbasis, tempts := monpolymult(eqs, [op(unHiddenVars), hiddenVar], varperm):
    
            numoftempts := numelems(tempts):
            Msymbolic := M:
            #======================================================================================
            # Reduce the matrix to a reduced row echelon form
            #======================================================================================
        Mreduced, reducedeqs, nc := reducepoly(M, originalbasis, noofrowstoreduce, noofdatacoeff, randrange, tempts):
    	numofncs := numelems(nc):

    	#======================================================================================
    	# Random instance for the reduced equations
    	#======================================================================================
    
        for i to noofdatacoeff do  
    		assign(cat('c', i), (i+ithprime(100))/(i-ithprime(10000))):
    	end do:
    	for i to numoftempts do 
    		assign(cat('t', i), tempts[i]): 
    	end do:
    
    	if noofrowstoreduce > 0 then
    		Mpatch:=LinearAlgebra[ReducedRowEchelonForm](convert(Msymbolic[1..noofrowstoreduce,..],Matrix)):
    		M := ArrayTools[Concatenate](1, Mpatch, evalm(convert(Msymbolic[noofrowstoreduce+1..,..], Matrix)) );
    	else
    		M := Msymbolic:
        end:
    	linearMnew := ArrayTools[Reshape](M, numelems(eqs)*numelems(originalbasis), 1):
    	for i to numofncs do 
    		assign(cat('nc', i), linearMnew[nc[i],1]): 
    	end do:
    
    	#======================================================================================
    	# We randomize the hidden variable as well
    	#======================================================================================
        assign(cat('a',hiddenVarNumber), RandomTools[Generate](rational)):
    
        #======================================================================================
        # We find sparse basis for the reduced equations. Here the coefficients are 'nc's.
    	#======================================================================================
        try:
            Boriginal, Toriginal, B, T := findsparseresultnat(reducedeqs, unHiddenVars, sizeofcombs, polycomb, theoreticalsolncnt, heurisitictemplatesize):
            Tn := convert(map(at -> Size(T[at])[1], [seq(1 .. numelems(T))]), `+`):
            Cr := polytomat(T, B, eval(reducedeqs), unHiddenVars, numelems(B), Tn):
            print(T, Tn, numelems(B));	
        	#======================================================================================
        	# We select the newly found basis only if it is smaller than the one previously selected.
            #======================================================================================		
        	if numelems(B) > 0 and numelems(B) < Bn then 
        		sparsebasis := B:
        		Bn := numelems(B):
        		monmultiples := T:
        		selectedhiddenvarind := hiddenvarind:
        		printf("Sparse basis size =  %d \n", numelems(sparsebasis));
        		printf(" No. of rows = %d \n", convert(map(at -> ArrayTools[Size](monmultiples[at])[1], [seq(1..numelems(eqs))]), `+`));
            end if:
        catch:
            print("error"):
        end try:
        #======================================================================================
        # Unassign everything. As the basis has been found and we do not need sample instance of reduced equations.
        #======================================================================================		
        unassign(cat('a',hiddenVarNumber)):
        for i to numofncs do
    		unassign(cat('nc',i)):
    	end do:
    	for i to numoftempts do
    		unassign(cat('t',i)):
    	end do:	
    	for i to noofdatacoeff do
    		unassign(cat('c',i)):
    	end do:

    end do:
end do:

hiddenVarNumber := acthiddenvarnumber:
hiddenVar := parse(cat("a", hiddenVarNumber)):
unHiddenVars := select(v -> v <> hiddenVar, vars):
vars := [op(unHiddenVars), hiddenVar]:

reducedeqs :=[]:
for ei to numelems(eqs) do 
	reducedeqs := [op(reducedeqs), evalm(Mreduced[ei,..] &* originalbasis)]:
end do:
#======================================================================================
# With the sparse basis obtained we construct a symbolic resultant matrix 
# which is to be solved for eigenvalues.
#======================================================================================		

temp := convert(monmultiples[-1], list, nested = true):
bbs := map(proc (i) options operator, arrow; select(proc (j) options operator, arrow; sparsebasis[j] = [temp[i][1], op(temp[i][2..])] end proc, [seq(1 .. numelems(sparsebasis))])[1] end proc, [seq(1 .. numelems(temp))]):
gbs := convert(convert([seq(1 .. numelems(sparsebasis))], set) minus convert(bbs, set), list):
sparsebasis := sparsebasis[[op(bbs), op(gbs)]]:
print(unHiddenVars);
Cred := polytomat(convert(monmultiples, list), sparsebasis, reducedeqs, unHiddenVars, Bn, Bn):

degreehidvar := max(map(proc (f) options operator, arrow; degree(f, cat('a',hiddenVarNumber)) end proc, Cred)):
allcs := map(proc (i) options operator, arrow; coeff(Cred, cat('a',hiddenVarNumber)^i) end proc, [seq(1 .. degreehidvar)]):
Cs := convert([coeff(Cred*cat('a',hiddenVarNumber), cat('a',hiddenVarNumber)), op(allcs)], Matrix):

printf("The size of sparse basis is %d .\n", Bn);

#======================================================================================
# Generating the solver and the template to calculate var values from eigen vectors
#======================================================================================
sparsebasis := LinearAlgebra[Transpose](convert(sparsebasis, Matrix)):
printf("Generating template to be used for extracting values of the un-hidden variables \n");

with(SolveTools): 
unassign('d'):
lambdas := Matrix(Size(sparsebasis)[2], 1, symbol = 'd'): 
solForm := Matrix(Size(sparsebasis)[2], Size(vars)[2]-1, symbol = 's'): 
for i to Size(vars)[2]-1 do 
	eVec := Matrix(Size(vars)[2], 1, 0): 
	eVec[i, 1] := 1: 
	polEqs := Matrix([[convert(sparsebasis, Matrix)], [Matrix(1, Size(sparsebasis)[2], 1)]]): 
	temp := LinearAlgebra[LinearSolve](polEqs, eVec, free = 'd'): 
	for j to Size(sparsebasis)[2] do 
		solForm[j, i] := temp[j]:
	end do 
end do: 

templateFileName := convert(cat(solverFolderName, "/solver_template.m"), string): 
fileName := convert(cat(solverFolderName, "/reduce_mon_basis.m"), string): 

printf("Loading the solver template for problem specific solver...\n"):
fd := fopen("PEP_solver_template.m",READ,TEXT):
	templateText := readbytes(fd, infinity):
fclose(fd):

fd := fopen(templateFileName,WRITE,TEXT):
	writeline(fd, cat("hiddenvarnumber = ",hiddenVarNumber, ";")):
	#writeline(fd, "for i = 1:length(data)"):
	#writeline(fd, "eval(strjoin({'c',num2str(i),' = ', 'data(',num2str(i),');'},''));"):
	#writeline(fd, "end"):
    writeline(fd, "c1 = data(1); c2 = data(2); c3 = data(3); c4 = data(4); c5 = data(5); c6 = data(6); c7 = data(7); c8 = data(8); c9 = data(9); c10 = data(10); c11 = data(11); c12 = data(12); c13 = data(13); c14 = data(14); c15 = data(15); c16 = data(16); c17 = data(17); c18 = data(18); c19 = data(19); c20 = data(20); c21 = data(21); c22 = data(22); c23 = data(23); c24 = data(24); c25 = data(25); c26 = data(26); c27 = data(27); c28 = data(28); c29 = data(29); c30 = data(30); c31 = data(31); c32 = data(32); c33 = data(33); c34 = data(34); c35 = data(35); c36 = data(36); c37 = data(37); c38 = data(38); c39 = data(39); c40 = data(40); c41 = data(41); c42 = data(42); c43 = data(43); c44 = data(44); c45 = data(45); c46 = data(46); c47 = data(47); c48 = data(48); c49 = data(49); c50 = data(50); c51 = data(51); c52 = data(52); c53 = data(53); c54 = data(54); c55 = data(55); c56 = data(56); c57 = data(57); c58 = data(58); c59 = data(59); c60 = data(60); c61 = data(61); c62 = data(62); c63 = data(63); c64 = data(64); c65 = data(65); c66 = data(66); c67 = data(67); c68 = data(68); c69 = data(69); c70 = data(70); c71 = data(71); c72 = data(72); c73 = data(73); c74 = data(74); c75 = data(75); c76 = data(76); c77 = data(77); c78 = data(78); c79 = data(79); c80 = data(80); c81 = data(81);"):
fclose(fd):

printf("Processing the sparse basis to estimate the solver based on eigenvalues and eigenvectors...\n"):
for k to ArrayTools[Size](sparsebasis)[2] do 
	assign(lambdas[k, 1], 0): 
end do: 

solFromEigenVectors := convert(evalm(solForm), Matrix): 
coeffMatNames := "": 
sizeOfCs := ArrayTools[Size](Cs)[1]:
fd := fopen(templateFileName,APPEND,TEXT):

for i to numoftempts do
	writeline(fd, cat("t",i, " = ",tempts[i] ,";")):
end do:

writeline(fd, convert(cat("M = zeros(",numelems(eqs), ",", numelems(originalbasis),");" ),string)):
for i to numelems(eqs) do
	for j to numelems(originalbasis) do
		if Msymbolic[i,j] <> 0 then
			writeline(fd, cat("M(",i,",",j,") = ", Msymbolic[i,j], ";")):
		end if:
	end do:
end do:
#for j to numelems(originalbasis) do
#	writeline(fd, cat("B(",j,") = eval('", convert(originalbasis[j],string), "');")):
#end do:
writeline(fd, cat("M = [rref(M(1:", noofrowstoreduce, ",:)); M(", (noofrowstoreduce+1), ":end,:)];")):
writeline(fd, cat("ncinds = ", convert(nc,string), ";")):
#writeline(fd, cat("for ncind = 1:",numofncs)):
#writeline(fd, cat("    eval(strjoin({'nc', num2str(ncind), ' = ', 'M(ncinds(ncind));'}, '') )") ):
#writeline(fd, cat("end")):
for j to 210 do
writeline(fd, cat("nc", convert(j,string), " = M(ncinds(", convert(j,string), "));")):
end do:
fclose(fd):

MatlabCodeCreator(coeffMatNames, "ArrayOfCsNames", templateFileName): 
MatlabCodeCreator(sizeOfCs, "sizeOfC", templateFileName): 
MatlabCodeCreator(Size(vars)[2], "noOfVars", templateFileName): 
MatlabCodeCreator(convert(sparsebasis, Matrix), "sparseBasis", templateFileName): 
MatlabCodeCreator(convert(map(proc (x) options operator, arrow: x[1] end proc, solFromEigenVectors), Matrix), "solFromEigenVectors", templateFileName):


fd := fopen(templateFileName,APPEND,TEXT):
writeline(fd, convert(cat("Cs = zeros(",ArrayTools[Size](Cs)[1], ",", ArrayTools[Size](Cs)[2],");" ),string)):
for j to ArrayTools[Size](Cs)[1] do
	for k to ArrayTools[Size](Cs)[2] do
		if Cs[j,k] <> 0 then
		    writeline(fd, convert(cat("Cs(",j, ",", k, ") = ", convert(simplify(Cs[j,k]),string), ";" ),string)):
		end if:
	end do:
end do:

writeline(fd, "indicesToRemove = [];"):
fclose(fd):

printf(" Copying the template to a temporary solver. \n");
fd := fopen(templateFileName,READ,TEXT):
CsTemplateText := readbytes(fd, infinity):
fclose(fd):

fd := fopen("find_non_zero_coeff_mat.m", READ,TEXT):
	temp2 := readbytes(fd, infinity):
fclose(fd):


fd := fopen(fileName, WRITE,TEXT):
	writeline(fd, "function[indicesToRemove, numOfRedCoeffMat, zeigvalindx, solverTemplate, extendedbasis, nullspacesize1, depdXcols1, nzrows1, depdCcols1, indepdCcols1, mdepdXcols1, mindepdXcols1, indepdCrows1, rowstorem1, nullspacesize2, depdXcols2, nzrows2, depdCcols2, indepdCcols2, mdepdXcols2, mindepdXcols2, indepdCrows2, rowstorem2, nullspacesize3, depdXcols3, nzrows3, depdCcols3, indepdCcols3, mdepdXcols3, mindepdXcols3, indepdCrows3, rowstorem3] = reducemonbasis(data, noofdatacoeff, foldername)"):
	writebytes(fd, CsTemplateText):
	writeline(fd, "indicesToSkip = fliplr(find(sum(transpose(solFromEigenVectors))~=0));"):
    writeline(fd, cat("sizeoffinalres =", numelems(bbs))):
	writeline(fd, cat("[reducedCs, reducedSparseBasis zeroMatrixIndices rowsToRemove colsToRemove] = reducemonbasis(Cs, transpose(solFromEigenVectors),1, 100.0, indicesToSkip);")):
	writebytes(fd, temp2):
fclose(fd):

printf(" The solver code is now generated in the form of file, PEP_solver.m \n");
