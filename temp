B1 := B: T1 := convert(T,list):
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T), `+`):

for counter from 1 to 1 do
randomize():
for dif in combinat[randperm](groupsofdifs) do
Boriginal :=B1:
while true do
	Bt := B1: Tt := T1:
	rowindices := [seq(1..convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, Tt), `+`))]: 
	Ct:= polytomat(Tt, Bt, eval(eqs), vars, numelems(Bt), convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, Tt), `+`)):

	zrowsbycol := map(i1 -> select(j1 -> Ct[j1, i1] <> 0, [seq(1 .. ArrayTools[Size](Ct)[1])]), [seq(1 .. numelems(Bt))]):
	colswithnrow := select(proc (i1) options operator, arrow; numelems(zrowsbycol[i1]) <= dif end proc, [seq(1 .. numelems(zrowsbycol))]):
	rows2rem := convert(convert(map(proc (c) options operator, arrow; op(c) end proc, zrowsbycol[colswithnrow]), set), list): 
    
	rows2kp := select(proc (i1) options operator, arrow; not(i1 in rows2rem) end proc, [seq(1 .. ArrayTools[Size](Ct,1))]): 
	Ct := Ct[rows2kp, () .. ()]:
	Ctb := map(proc (c) options operator, arrow; `if`(c = 0, 0, 1) end proc, Ct): 
    
	zdcols := convert(ArrayTools[AddAlongDimension](Ctb, 1), list): 
    colstokp := select(proc (i1) options operator, arrow; zdcols[i1] <> 0 end proc, [seq(1 .. numelems(zdcols))]):
	cols2rem := select(proc (i1) options operator, arrow; zdcols[i1] = 0 end proc, [seq(1 .. numelems(zdcols))]): 
	Ct := Ct[() .. (), colstokp]: 
	Bt := Bt[colstokp]:
	if numelems(cols2rem) = 0 then break: end if:
	
	rowindices := rowindices[rows2kp]:
	Tt:=map(i -> Tt[i][select(j -> j+convert(map(t->ArrayTools[Size](Tt[t],1), [seq(1 .. numelems(Tt[..i-1]))]), `+`) in rowindices, [seq(1..ArrayTools[Size](Tt[i],1))]),..], [seq(1..numelems(Tt))]):	
	if convert(map(t->ArrayTools[Size](t,1), Tt), `*`) = 0  then break: end if:

	temp := convert(Tt[-1], list, nested = true):
	bbs := map(i1 -> select(j1 -> Bt[j1] = [temp[i1][1], op(temp[i1][2..])], [seq(1 .. numelems(Bt))])[1], [seq(1 .. numelems(temp))]):
	gbs := convert(convert([seq(1 .. numelems(Bt))], set) minus convert(bbs, set), list):
	Ck := Ct[[seq(1..convert(map(t -> ArrayTools[Size](t,1), Tt[..-2]), `+`))], gbs]:
	difff := ArrayTools[Size](Ck)[2]-LinearAlgebra[Rank](Ck):
    
	if difff <> 0 then 
        break: 
    end if:
    B1 := Bt: T1 := Tt:
end do:
end do:
end do:
T:=T1: B:=B1:
Tn := convert(map(proc (t) options operator, arrow; ArrayTools[Size](t,1) end proc, T), `+`):


